/* 哈希算法：
    无论是开放寻址还是链式寻址，它们只能保证哈希表可以在发生冲突的时候正常工作，而无法减少哈希冲突的发生。
    如果哈希冲突过于频繁，则会是哈希表的性能急剧恶化。
    对于链式地址哈希表，理想情况下键值对均匀分布在各个桶里，达到最佳的查询效率；
    最差情况下，所有键值对都存储在一个桶里，时间复杂度退化至O(n)。
    键值对的分布情况由哈希函数决定。
    index = hash(key) % capacity
    当哈希表容量capacity固定时，哈希算法hash()决定了输出值，进而决定了键值对在哈希表中的分布情况。
    这意味着，为了降低哈希冲突的发生概率，我们应当将注意力集中在哈希算法的设计上。
     */

/* 哈希算法的目标：
    为了实现“既快又稳”的哈希表数据结构，哈希算法应具备以下特点。
        1.确定性：对于相同的输入，哈希算法应该始终输出相同的输出，这样才能保证哈希表是可靠的。
        2.效率高：计算哈希值的过程应该足够快。计算开销越小，哈希表的实用性越高。
        3.均匀分布：哈希算法应使得键值对均匀分布在哈希表中。分布越均匀，哈希冲突的概率越低。
    实际上，哈希算法除了可以应用在哈希表的实现上，还广泛的应用于其他领域。
        1.密码存储：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希值。当用户输入密码时，系统会对输入的值计算哈希值，然后与存储的哈希值进行比较。
        如果两者一致，那么密码就算是正确。
        2.数据完整性检查：数据发送方可以计算数据的哈希值并将其一同发送；接收方可以重新计算接收到的数据的哈希值，并与接收到的哈希值进行比较。如果两者匹配，那么数据就被视为完整。
    对于密码学的相关应用，为了防止从哈希值推导出原始密码等逆向工程，哈希算法需要具备更高等级的安全特性。
        1.单向性：无法通过哈希值发推出关于输入数据的任何信息。
        2.抗碰撞性：应当极难找到两个不同的输入，使得他们的哈希值相同。
        3.雪崩效应：输入的微小变化应当导致输出的显著且不可预测的变化。
    请注意，“均匀分布”和“抗碰撞性”是两个独立的概念，满足均匀分布不一定满足抗碰撞性。例如，在随机输入key下，哈希函数key%100可以产生均匀分布的输出。
    然而，该哈希算法过于简单，所有后两位相等的key的输出都相同，因此我们可以很容易地从哈希值反推出可用的key，从而破解密码。
*/


fn main() {
    println!("哈希算法的学习");
}

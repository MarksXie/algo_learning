/* 二叉树是一种非线性数据结构，代表“祖先“和”后代“之间的派生关系，体现了”一分为二“的分治逻辑。与链表类似，二叉树的基本单元是节点，
每个节点包含值、左子节点引用和右子节点引用。 */

use std::rc::Rc;
use std::cell::RefCell;

#[allow(dead_code)]
/* 二叉树节点结构体 */
struct TreeNode{
    val: i32,   // 节点值
    left: Option<Rc<RefCell<TreeNode>>>,    // 左子节点引用
    right: Option<Rc<RefCell<TreeNode>>>,   // 右子节点引用
}
/* 每个节点都有两个引用，分别指向左子节点和右子节点，该节点被称为这两个子节点的父节点。当给定一个二叉树节点时，我们将该节点的左子节点
及其以下的树称为该节点的左子树，同理可得右子树。
    在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树。 */

/* 二叉树常见术语：
    1.根节点： 位于二叉树顶层的节点，没有父节点。
    2.叶节点： 没有子节点的节点，其两个指针均指向None。
    3.边： 连接两个节点的线段，即节点引用。
    4.节点所在的层： 从顶至底递增，根节点所在层为1。
    5.节点的度： 节点的子节点的数量。在二叉树中，度的取值范围为0、1、2。
    6.二叉树的高度： 从根节点到最远叶节点所经过的边的数量。
    7.节点的深度： 从根节点到该节点所经过的边的数量。
    8.节点的高度： 从距离该节点最远的叶节点到该节点的所经过的边的数量。 */


#[allow(dead_code)]
impl TreeNode {
    /* 构造方法 */
    fn new(val: i32) -> Rc<RefCell<Self>> {
        Rc::new(RefCell::new(Self { val: val, left: None, right: None }))
    }
}

fn main() {
    /* 初始化二叉树 */
    // 初始化节点
    let n1 = TreeNode::new(1);
    let n2 = TreeNode::new(2);
    let n3 = TreeNode::new(3);
    let n4 = TreeNode::new(4);
    let n5 = TreeNode::new(5);

    // 构建节点之间的引用(指针)
    n1.borrow_mut().left = Some(n2.clone());
    n1.borrow_mut().right = Some(n3);
    n2.borrow_mut().left = Some(n4);
    n2.borrow_mut().right = Some(n5);

    /* 插入与删除节点 */
    let p = TreeNode::new(0);
    // 在n1 -> n2中间插入节点p
    n1.borrow_mut().left = Some(p.clone());
    p.borrow_mut().left = Some(n2.clone());

    // 删除节点
    n1.borrow_mut().left = Some(n2);

    /* Tips: 需要注意的是，插入节点可能会改变二叉树原来的逻辑结构，而删除节点通常意味着删除该节点及该节点下的所有子树。
    因此，在二叉树中，插入和删除通常是由一套操作配合完成的，以实现有实际意义的操作。 */

}

/* 常见二叉树类型
    1.完美二叉树(满二叉树)： 二叉树的所有层的节点都被完全填满。在完美二叉树中，叶节点的度为0，其余所有节点的度都为2；若书的高度为h，则
    节点总数为2.pow(h+1)-1，呈现标准的指数级关系，反应了自然界中常见的细胞分裂现象。 除了最底层节点外，所有节点的度都是2.
    2.完全二叉树： 完全二叉树只有最底层的节点未被填满，且最底层节点尽量靠坐填充。请注意，完全二叉树也是一个完全二叉树。
    3.完满二叉树： 完满二叉树除了叶节点之外，其余所有节点都有两个子节点。所有节点的度都为0或者2。
    4.平衡二叉树： 平衡二叉树中任意节点的左子树和右子树的高度之差的绝对值不超过1。
    */

/* 二叉树的退化
    当二叉树的每层节点都被填满时，达到“完美二叉树“；而当所有节点都偏向一侧时，二叉树退化为”链表“。
        1.完美二叉树是理想情况，可以充分发挥二叉树”分治“的优势。
        2.链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化为O(n). */


/* 物理结构很大程度上决定了程序对内存和缓存的使用效率，进而影响算法程序的整体性能。
    1.数据结构的内存效率
        1.内存是有限的，且同一块内存不能被u多个程序共享，因此我们希望数据结构能够尽可能高效地利用空间。数组的元素紧密排列，不需要额外的空间来存储链表节点间的引用（指针），因此
        空间效率更高。但是，数组需要一次性分配足够的连续内存空间，这可能导致额外的空间浪费，且数组的扩容也需要额外的时间和空间成本。相比之下，链表是以节点为单位进行动态的内存分配
        和回收，提供了更大的灵活性。
        2.在程序的运行过程中，随着反复的申请和释放内存，空闲内存的碎片化程度会越来越高，从而导致内存的利用效率降低。数组由于其连续的存储方式，相对不容易导致内存碎片化。相反，链表的元素是分散存储的，
        在频繁的插入和删除操作中，更容易导致内存碎片化。
    2.数据结构的缓存效率
        如果CPU尝试访问的数据不在缓存中，就会发生缓存未命中(cache miss)，此时CPU从速度较慢的内存中加载所需的数据。
        显然，cache miss越少，CPU读写的效率就越高，程序的性能就越好。我们将CPU从缓存中成功获取到数据的比例称为缓存命中率(cache hit rate)，这个指标通常用来衡量缓存效率。
        为了尽可能达到更高的效率，缓存会采取以下数据加载机制：
        1.缓存行：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。相比于单个字节的传输，缓存行的传输方式更加高效。
        2.预取机制：处理器会尝试预测数据访问模式(例如顺序访问、固定步跳跃访问等)，并根据特定的模式将数据加载至缓存之中，从而提升命中率。
        3.空间局部性：如果一个数据被访问，那该数据的周围的数据也可能被访问。因此，缓存在加载某一个数据的时候，也会将它周围的数据一起加载，以提升命中率。
        4.时间局部性：如果一个数据被访问，那么它在不久的将来很可能会被再次访问。所以，缓存利用这一原理，通过保留最近访问过的数据来提高命中率。
        
    实际上，数组和链表对缓存的利用效率是不同的，主要体现在以下几个方面：
        1.占用空间：链表元素比数组元素占用的空间更多，导致缓存中容纳的有效数据量更少。
        2.缓存行：链表数据分散在内存各处，而缓存是“按行加载”的，因此加载到无效数据的比例更高。
        3.预取机制：数组比链表更具有可预测性，即系统更容易猜出即将被加载的数据。
        4.空间局部性：数组被存储在集中的内存空间中，因此被加载数据的附近的数据也更有可能被访问。
    总体而言，数据具有更高的缓存命中率，因此它在操作效率上通常由于链表。
    但是，高缓存命中率不意味着数组在任何情况下都是由于链表的。在实际应用中选择哪种数据结构，应根据具体的场景需求来决定。
        1.在做算法题的时候，我们通常会倾向于选择基于数组的栈，因为它提供了更高的操作效率和随机访问的能力，代价仅仅是需要预先为数组分配一定的存储空间。
        2.如果数据量非常大、动态性很高、栈的预估大小很难估计，那么基于链表实现的栈更合适。链表能够将大量数据分散存储在内存的不同部分，并且避免了数组扩容时带来的额外开销。*/


fn main() {
    println!("内存与缓存，学习！");
}
